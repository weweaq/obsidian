# jvm的位置与体系结构
jvm在jre中

![[Pasted image 20240520231850.png]]

# 类加载器-双亲委派机制

## 1. 哪些类加载器

1. 引导类加载器（BootstrapClassloader）：用C++编写，是JVM自带的类加载器；负责加载Java的核心类库。（该加载器无法直接获取）
2. 扩展类加载器（ExtClassloader）：负责加载/jre/lib/ext目录下的jar包。
3. 应用程序类加载器（AppClassloader）：负责加载java -classpath或-D java.class.path所指的目录下的类与jar包。（最常用的加载器）

## 2.双亲委派机制
1. 类加载器接收到一个加载请求时，他会委派给他的父加载器，实际上是去他父加载器的缓存中去查找是否有该类，如果有则会继续往上层委派，直到顶层类加载器，使用最高层的加载器。
2. 若最高层没有对应的类加载器，则只会使用可用的最高层类加载器。
![[Pasted image 20240520232729.png]]

# native方法

凡是使用了native关键字的，说明Java的作用范围已经达不到了，它会去调用底层的C语言的库。

1. 进入本地方法栈。
2. 调用本地方法接口。JNI

JNI的作用：扩展Java的使用，融合不同的语言为Java所用。（最初是为了融合C、C++语言）

所以Java在JVM内存区域专门开辟了一块标记区域Native Method Area Stack，用来登记native方法。  

在最终执行（执行引擎执行）的时候，通过JNI来加载本地方法库中的方法。

# 堆

Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。

类加载器读取了类文件后，一般会把什么东西放到堆中？  
类、方法、常量、变量、保存我们所有引用类型的真实对象。

堆内存中细分为三个区域：

- 新生区（伊甸园区）Young/New
	- eden 伊甸园区
	- s0 幸存区 0 
	- s1 幸存区1
- 养老区 old
- 永久区 Perm

## 永久区

这个区域是**常驻内存**的，**不存在垃圾回收**。  

用来存放JDK自身携带的Class对象、Interface元数据，存储的是Java运行时的一些环境或类信息

关闭JVM虚拟机就会释放这个区域的内存。

### 什么情况下，在永久区就崩了？

- 一个启动类，加载了大量的第三方jar包。
- Tomcat部署了太多的应用。
- 大量动态生成的反射类；不断的被加载，直到内存满，就会出现OOM

元空间 == 永久代 == 逻辑上存在，物理上不存在

# 使用JProfiler工具分析OOM原因

